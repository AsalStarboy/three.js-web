<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vestas Turbine Interactive</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a202c; color: #e2e8f0; }
        #webgl-output { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(7, 10, 200, 0.7); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem; z-index: 1000; flex-direction: column; gap: 1rem;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hotspot-label {
            position: absolute;
            background: #e53e3e;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            white-space: nowrap;
            z-index: 20;
            display: none;
            transition: opacity 0.2s;
        }
        .hotspot-popup {
            position: absolute;
            background: #fff;
            color: #222;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            padding: 1.5rem 1.5rem 1rem 1.5rem;
            min-width: 260px;
            z-index: 1001;
            display: none;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .hotspot-popup h3 { margin-top: 0; }
        .hotspot-popup .close-btn {
            position: absolute; top: 8px; right: 12px; background: none; border: none; font-size: 1.2rem; cursor: pointer;
        }
        .hotspot-popup .learn-more-btn {
            background: #3498db; color: #fff; border: none; border-radius: 4px; padding: 0.5rem 1rem; cursor: pointer; margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>Vestas Learning...</p>
    </div>
    <div id="webgl-output"></div>
    <!-- Hotspot Popup -->
    <div id="hotspot-popup" class="hotspot-popup">
        <button class="close-btn" onclick="document.getElementById('hotspot-popup').style.display='none'">&times;</button>
        <h3 id="popup-title"></h3>
        <p id="popup-desc"></p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let ambientLight, directionalLight;
        let bladesModel = null;
        let bladesPivot = null;
        const loadingOverlay = document.getElementById('loading-overlay');
        const container = document.getElementById('webgl-output');
        const currentCameraId = 1; // For future: change this to switch camera/hotspot sets

        // === HOTSPOTS: Easily adjust position/look/move for each ===
        // All positions are (x, y, z) in scene units.
        const hotspots = [
            {
                name: "Turbine",
                // Position this marker at the very top of the turbine
                position: { x: 0, y: 260, z: 0 }, // adjust y for your model's top
                cameraLookPosition: { x: 0, y: 260, z: 0 },
                cameraMovePosition: { x: 150, y: 270, z: 180 }, // adjust for best view
                cameraIds: [1],
                title: "Turbine",
                desc: "This is the top of the wind turbine.",
            },
            {
                name: "Tower",
                // Place this at the base or middle of the tower
                position: { x: 0, y: 120, z: 0 },
                cameraLookPosition: { x: 0, y: 120, z: 0 },
                cameraMovePosition: { x: 120, y: 130, z: 200 },
                cameraIds: [1],
                title: "Tower",
                desc: "This is the tower of the wind turbine.",
            },
            {
                name: "Car",
                // Placeholder! Adjust position when you add your car model
                position: { x: 60, y: 5, z: 90 },
                cameraLookPosition: { x: 60, y: 5, z: 90 },
                cameraMovePosition: { x: 80, y: 18, z: 140 },
                cameraIds: [1],
                title: "Car",
                desc: "This is the placeholder for the car model.",
            }
        ];
        const hotspotMeshes = [];
        const hotspotLabels = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            // Set initial camera position for general overview
            camera.position.set(200, 130, 300);
            camera.lookAt(0, 100, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI / 2;
            // Lock zoom: camera can't zoom in/out
            const lockedDistance = camera.position.distanceTo(new THREE.Vector3(0, 100, 0));
            controls.minDistance = lockedDistance;
            controls.maxDistance = lockedDistance;
            controls.enableZoom = false;
            controls.enablePan = false;
            controls.target.set(0, 100, 0);
            controls.update();

            ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const loader = new THREE.GLTFLoader();

            // Load main windmill model
            loader.load(
                'windmillenv.glb',
                function (gltf) {
                    const model = gltf.scene;
                    model.scale.set(2, 2, 2);
                    scene.add(model);
                    loadingOverlay.style.display = 'none';
                },
                undefined,
                function (error) {
                    console.error('An error occurred while loading the model:', error);
                    loadingOverlay.innerHTML = '<p class="text-red-500">Failed to load 3D model.</p>';
                }
            );

            // Create a pivot for the blades at the hub position
            bladesPivot = new THREE.Object3D();
            bladesPivot.position.set(0, 187, 0);
            scene.add(bladesPivot);

            // Load Blades.glb and add to pivot
            loader.load(
                'Blades.glb',
                function (gltf) {
                    bladesModel = gltf.scene;
                    bladesModel.scale.set(2, 2, 2);
                    bladesModel.position.set(0, 0, 0);
                    bladesModel.rotation.set(0, 0, 0);
                    bladesPivot.add(bladesModel);
                },
                undefined,
                function (error) {
                    console.error('An error occurred while loading Blades.glb:', error);
                }
            );

            // --- Add Hotspots to Scene ---
            hotspots.forEach((hotspot, idx) => {
                if (!hotspot.cameraIds.includes(currentCameraId)) return; // Only show for this camera

                // Sprite marker for the hotspot
                const map = new THREE.TextureLoader().load(
                    "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='28' fill='%23e53e3e' fill-opacity='0.7'/></svg>"
                );
                const material = new THREE.SpriteMaterial({ map: map, transparent: true, opacity: 1, depthTest: false });
                const sprite = new THREE.Sprite(material);
                sprite.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
                sprite.scale.set(16, 16, 1);
                sprite.renderOrder = 999;
                sprite.userData.hotspotIndex = idx;
                scene.add(sprite);
                hotspotMeshes.push(sprite);

                // HTML Label
                const label = document.createElement('div');
                label.className = 'hotspot-label';
                label.innerText = hotspot.name;
                document.body.appendChild(label);
                hotspotLabels.push(label);
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Hotspot Interactivity ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let INTERSECTED = null;

        const popup = document.getElementById('hotspot-popup');
        const popupTitle = document.getElementById('popup-title');
        const popupDesc = document.getElementById('popup-desc');

        function setupHotspotEvents() {
            renderer.domElement.addEventListener('mousemove', (event) => {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(hotspotMeshes);

                hotspotLabels.forEach(label => label.style.display = 'none');
                INTERSECTED = null;

                if (intersects.length > 0) {
                    const idx = intersects[0].object.userData.hotspotIndex;
                    INTERSECTED = idx;
                    hotspotLabels[idx].style.display = 'block';
                    const vector = hotspotMeshes[idx].position.clone().project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    hotspotLabels[idx].style.left = `${x}px`;
                    hotspotLabels[idx].style.top = `${y - 30}px`;
                }
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                hotspotLabels.forEach(label => label.style.display = 'none');
                INTERSECTED = null;
            });

            renderer.domElement.addEventListener('click', (event) => {
                if (INTERSECTED !== null) {
                    const hotspot = hotspots[INTERSECTED];
                    animateCameraTo(hotspot.cameraMovePosition, hotspot.cameraLookPosition);

                    // Show popup (optional, remove if you don't need)
                    popupTitle.innerText = hotspot.title;
                    popupDesc.innerText = hotspot.desc;
                    popup.style.display = 'block';
                }
            });
        }

        document.querySelector('.close-btn').onclick = () => {
            popup.style.display = 'none';
        };

        function updateHotspotLabels() {
            hotspotMeshes.forEach((mesh, idx) => {
                if (hotspotLabels[idx].style.display === 'block') {
                    const vector = mesh.position.clone().project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    hotspotLabels[idx].style.left = `${x}px`;
                    hotspotLabels[idx].style.top = `${y - 30}px`;
                }
            });
        }

        // Animate camera to new position/target
        function animateCameraTo(targetPosition, lookAtPosition, duration = 1000) {
            const startPosition = camera.position.clone();
            const startLookAt = controls.target.clone();
            const endPosition = new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z);
            const endLookAt = new THREE.Vector3(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                camera.position.lerpVectors(startPosition, endPosition, t);
                controls.target.lerpVectors(startLookAt, endLookAt, t);
                controls.update();
                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        function animateFn() {
            requestAnimationFrame(animateFn);
            controls.update();

            if (bladesPivot) {
                bladesPivot.rotation.z += 0.02;
            }

            // Hotspot fade based on camera distance
            const fadeStart = 80;
            const fadeEnd = 200;
            hotspotMeshes.forEach((sprite, idx) => {
                const dist = camera.position.distanceTo(sprite.position);
                let opacity = 1;
                if (dist > fadeStart) {
                    opacity = 1 - (dist - fadeStart) / (fadeEnd - fadeStart);
                    opacity = Math.max(0, Math.min(1, opacity));
                }
                sprite.material.opacity = opacity;
                if (opacity < 0.05) hotspotLabels[idx].style.display = 'none';
            });

            renderer.render(scene, camera);
            updateHotspotLabels();
        }

        window.onload = function () {
            init();
            setupHotspotEvents();
            animateFn();
        };
    </script>
</body>
</html>
