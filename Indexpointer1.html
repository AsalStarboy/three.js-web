<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vestas Turbine Interactive</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a202c; color: #e2e8f0; }
        #webgl-output { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(7, 10, 200, 0.7); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem; z-index: 1000; flex-direction: column; gap: 1rem;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hotspot-label {
            position: absolute;
            background: #3498db;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            white-space: nowrap;
            z-index: 20;
            display: none;
            transition: opacity 0.2s;
        }
        .hotspot-popup {
            position: absolute;
            background: #fff;
            color: #222;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            padding: 1.5rem 1.5rem 1rem 1.5rem;
            min-width: 260px;
            z-index: 1001;
            display: none;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .hotspot-popup h3 { margin-top: 0; }
        .hotspot-popup .close-btn {
            position: absolute; top: 8px; right: 12px; background: none; border: none; font-size: 1.2rem; cursor: pointer;
        }
        .hotspot-popup .learn-more-btn {
            background: #3498db; color: #fff; border: none; border-radius: 4px; padding: 0.5rem 1rem; cursor: pointer; margin-top: 1rem;
        }
        #toggle-bbox-btn {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 2000;
            background: #222;
            color: #ffe600;
            border: none;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            font-size: 1rem;
            cursor: pointer;
            opacity: 0.85;
        }
        #toggle-bbox-btn:hover {
            opacity: 1;
            background: #ffe600;
            color: #222;
        }
        /* Navigation Bar Styles */
        #nav-bar {
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1100;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 24px;
            padding: 10px 30px;
            display: flex;
            align-items: center;
            gap: 24px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.05);
        }
        #nav-bar .arrow-btn {
            border: none;
            background: #3498db;
            color: #fff;
            font-size: 1.4rem;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #nav-bar .arrow-btn:active {
            background: #2563eb;
        }
        #nav-bar .part-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: #ffe600;
        }
    </style>
</head>
<body>
    <button id="toggle-bbox-btn">Hide Bounding Box</button>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>Vestas Learning...</p>
    </div>
    <div id="webgl-output"></div>
    <!-- Hotspot Popup -->
    <div id="hotspot-popup" class="hotspot-popup">
        <button class="close-btn" onclick="document.getElementById('hotspot-popup').style.display='none'">&times;</button>
        <h3 id="popup-title"></h3>
        <p id="popup-desc"></p>
        <button id="popup-learn-btn" class="learn-more-btn">Learn More</button>
    </div>
    <!-- Navigation Bar -->
    <div id="nav-bar">
        <button class="arrow-btn" id="prev-btn">&#8592;</button>
        <span class="part-name" id="part-name"></span>
        <button class="arrow-btn" id="next-btn">&#8594;</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let ambientLight, directionalLight;
        let mainModel = null;
        let partMeshes = []; // Will hold references to all part meshes
        let mainModelBox = null;
        let boxHelper = null;
        const loadingOverlay = document.getElementById('loading-overlay');
        const container = document.getElementById('webgl-output');

        // --- Parts Data: Extend for more parts ---
        const parts = [
            {
                name: "Blades",
                camera: { position: [300, 200, 100], target: [0, 120, 0] },
                title: "Blades",
                desc: "Wind turbine blades capture wind and convert it into rotational energy.",
                url: "https://en.wikipedia.org/wiki/Wind_turbine_blades",
                hotspot: { x: 0, y: 198, z: -20 }
            },
            {
                name: "Hub",
                camera: { position: [100, 250, 200], target: [0, 190, 0] },
                title: "Hub",
                desc: "The hub connects the blades and is mounted on the main shaft.",
                url: "https://en.wikipedia.org/wiki/Pitch_bearing",
                hotspot: { x: 0, y: 190, z: 0 }
            },
            {
                name: "Nacelle",
                camera: { position: [150, 300, 150], target: [0, 210, 0] },
                title: "Nacelle",
                desc: "The nacelle houses the generator, gearbox, and other key components.",
                url: "https://en.wikipedia.org/wiki/Wind_turbine_nacelle",
                hotspot: { x: 0, y: 210, z: 40 }
            }
            // Add more parts as needed
        ];
        let currentPartIdx = 0;

        // --- Hotspot Data ---
        const hotspotMeshes = [];
        const hotspotLabels = [];

        // --- Camera Animation ---
        let cameraAnim = {
            active: false,
            start: null,
            duration: 900,
            fromPos: null,
            toPos: null,
            fromTarget: null,
            toTarget: null
        };

        function animateCameraTo(position, target, duration = 900) {
            cameraAnim.active = true;
            cameraAnim.start = performance.now();
            cameraAnim.duration = duration;
            cameraAnim.fromPos = camera.position.clone();
            cameraAnim.toPos = new THREE.Vector3(...position);
            cameraAnim.fromTarget = controls.target.clone();
            cameraAnim.toTarget = new THREE.Vector3(...target);
        }

        function updateCameraAnim() {
            if (!cameraAnim.active) return;
            const elapsed = performance.now() - cameraAnim.start;
            const t = Math.min(elapsed / cameraAnim.duration, 1);
            camera.position.lerpVectors(cameraAnim.fromPos, cameraAnim.toPos, t);
            controls.target.lerpVectors(cameraAnim.fromTarget, cameraAnim.toTarget, t);
            controls.update();
            if (t >= 1) cameraAnim.active = false;
        }

        function selectPart(idx, animate = true) {
            currentPartIdx = idx;
            updateNavBar();
            const part = parts[idx];
            // Animate camera to part's preset
            if (animate) animateCameraTo(part.camera.position, part.camera.target);
            // Highlight selected part
            partMeshes.forEach((mesh, i) => {
                if (!mesh) return;
                if (i === idx) setMaterialAlpha(mesh, 1);
                else setMaterialAlpha(mesh, 0.23);
            });
            // Show popup for this part
            showPopupForPart(part);
        }

        function setMaterialAlpha(mesh, alpha) {
            mesh.traverse(child => {
                if (child.isMesh) {
                    if (!child.material) return;
                    child.material.transparent = true;
                    child.material.opacity = alpha;
                    child.material.needsUpdate = true;
                }
            });
        }

        // --- Navigation Bar ---
        function updateNavBar() {
            document.getElementById('part-name').innerText = parts[currentPartIdx].name;
        }
        document.getElementById('prev-btn').onclick = () => {
            let idx = (currentPartIdx - 1 + parts.length) % parts.length;
            selectPart(idx);
        };
        document.getElementById('next-btn').onclick = () => {
            let idx = (currentPartIdx + 1) % parts.length;
            selectPart(idx);
        };

        // --- Info Popup ---
        const popup = document.getElementById('hotspot-popup');
        const popupTitle = document.getElementById('popup-title');
        const popupDesc = document.getElementById('popup-desc');
        const popupLearnBtn = document.getElementById('popup-learn-btn');
        function showPopupForPart(part) {
            popupTitle.innerText = part.title;
            popupDesc.innerText = part.desc;
            popupLearnBtn.onclick = () => window.open(part.url, '_blank');
            popup.style.display = 'block';
        }
        document.querySelector('.close-btn').onclick = () => {
            popup.style.display = 'none';
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(330, 180, 180);
            camera.lookAt(0, 100, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.07;
            controls.minDistance = 5;
            controls.maxDistance = 600;
            controls.target.set(0, 120, 0);
            controls.update();

            ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const loader = new THREE.GLTFLoader();

            // Load windmill model (assume all in one, but you can segment meshes by name)
            loader.load(
                'windmillenv.glb',
                function (gltf) {
                    mainModel = gltf.scene;
                    mainModel.scale.set(2, 2, 2);
                    scene.add(mainModel);
                    loadingOverlay.style.display = 'none';
                    
                    // Try to find and store references to part meshes by name
                    parts.forEach((part, i) => {
                        // Look for mesh with matching name (case-insensitive)
                        let found = null;
                        mainModel.traverse(child => {
                            if (child.isMesh && child.name && child.name.toLowerCase().includes(part.name.toLowerCase())) {
                                found = child;
                            }
                        });
                        partMeshes[i] = found;
                    });

                    // Set initial opacity for all parts
                    partMeshes.forEach((mesh, i) => {
                        if (!mesh) return;
                        setMaterialAlpha(mesh, i === currentPartIdx ? 1 : 0.23);
                    });

                    // Bounding box
                    mainModelBox = new THREE.Box3().setFromObject(mainModel);
                    boxHelper = new THREE.Box3Helper(mainModelBox, 0xffff00);
                    scene.add(boxHelper);

                    addHotspots();
                    selectPart(currentPartIdx, false);
                },
                undefined,
                function (error) {
                    console.error('An error occurred while loading the model:', error);
                    loadingOverlay.innerHTML = '<p class="text-red-500">Failed to load 3D model.</p>';
                }
            );
            window.addEventListener('resize', onWindowResize, false);
        }

        function addHotspots() {
            // Remove old
            hotspotMeshes.forEach(sprite => scene.remove(sprite));
            hotspotLabels.forEach(label => document.body.removeChild(label));
            hotspotMeshes.length = 0;
            hotspotLabels.length = 0;

            parts.forEach((part, idx) => {
                const map = new THREE.TextureLoader().load(
                    "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='28' fill='%233498db' fill-opacity='0.5'/></svg>"
                );
                const material = new THREE.SpriteMaterial({ map: map, transparent: true, opacity: 1, depthTest: false });
                const sprite = new THREE.Sprite(material);
                sprite.position.set(part.hotspot.x, part.hotspot.y, part.hotspot.z);
                sprite.scale.set(16, 16, 1);
                sprite.renderOrder = 999;
                sprite.userData.partIndex = idx;
                scene.add(sprite);
                hotspotMeshes.push(sprite);

                // HTML Label
                const label = document.createElement('div');
                label.className = 'hotspot-label';
                label.innerText = part.name;
                document.body.appendChild(label);
                hotspotLabels.push(label);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Bounding Box Toggle
        let bboxVisible = true;
        document.getElementById('toggle-bbox-btn').onclick = function () {
            bboxVisible = !bboxVisible;
            if (boxHelper) boxHelper.visible = bboxVisible;
            this.textContent = bboxVisible ? "Hide Bounding Box" : "Show Bounding Box";
        };

        // Hotspot Interactivity
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let INTERSECTED = null;
        function setupHotspotEvents() {
            renderer.domElement.addEventListener('mousemove', (event) => {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(hotspotMeshes);

                hotspotLabels.forEach(label => label.style.display = 'none');
                INTERSECTED = null;

                if (intersects.length > 0) {
                    const idx = intersects[0].object.userData.partIndex;
                    INTERSECTED = idx;
                    hotspotLabels[idx].style.display = 'block';
                    const vector = hotspotMeshes[idx].position.clone().project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    hotspotLabels[idx].style.left = `${x}px`;
                    hotspotLabels[idx].style.top = `${y - 30}px`;
                }
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                hotspotLabels.forEach(label => label.style.display = 'none');
                INTERSECTED = null;
            });

            renderer.domElement.addEventListener('click', () => {
                if (INTERSECTED !== null) {
                    selectPart(INTERSECTED);
                }
            });
        }

        function updateHotspotLabels() {
            hotspotMeshes.forEach((mesh, idx) => {
                if (hotspotLabels[idx].style.display === 'block') {
                    const vector = mesh.position.clone().project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    hotspotLabels[idx].style.left = `${x}px`;
                    hotspotLabels[idx].style.top = `${y - 30}px`;
                }
            });
        }

        // --- Auto-Rotate Camera (on initial load, disabled on user interaction) ---
        let autoRotateActive = true;
        let autoRotateStart = performance.now();
        function autoRotateCamera() {
            if (!autoRotateActive) return;
            const elapsed = (performance.now() - autoRotateStart) / 1000;
            const radius = 360, height = 180;
            const angle = elapsed * 0.25; // Slow rotation
            camera.position.x = Math.cos(angle) * radius;
            camera.position.z = Math.sin(angle) * radius;
            camera.position.y = height;
            controls.target.set(0, 120, 0);
            controls.update();
        }
        renderer && renderer.domElement.addEventListener('pointerdown', () => { autoRotateActive = false; });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (autoRotateActive) autoRotateCamera();
            else updateCameraAnim();

            controls.update();

            // Fade hotspots based on camera distance
            const fadeStart = 120, fadeEnd = 300;
            hotspotMeshes.forEach((sprite, idx) => {
                const dist = camera.position.distanceTo(sprite.position);
                let opacity = 1;
                if (dist > fadeStart) {
                    opacity = 1 - (dist - fadeStart) / (fadeEnd - fadeStart);
                    opacity = Math.max(0, Math.min(1, opacity));
                }
                sprite.material.opacity = opacity;
                if (opacity < 0.05) hotspotLabels[idx].style.display = 'none';
            });

            renderer.render(scene, camera);
            updateHotspotLabels();
        }

        window.onload = function () {
            init();
            setupHotspotEvents();
            animate();
            updateNavBar();
        };
    </script>
</body>
</html>