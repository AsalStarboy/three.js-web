<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vestas Turbine Interactive</title>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a202c; color: #e2e8f0;}
        #webgl-output { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1;}
        #loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #101727; display: flex; justify-content: center; align-items: center; color: white; z-index: 99;}
        .welcome-text { font-family: 'Inter', sans-serif; font-weight: 400; font-size: 1em; letter-spacing: 0.2px; color: #e2e8f0; margin-top: 0.5em; opacity: 0.85;}
        .turbine-spinner { width: 60px; height: 60px; position: relative; animation: spinner-rotate 1.1s linear infinite; display: block; margin: 0 auto;}
        .turbine-blade { position: absolute; left: 50%; top: 50%; width: 44px; height: 6px; background: #fff; transform-origin: 0% 50%; clip-path: polygon(0% 30%, 90% 0%, 100% 50%, 90% 100%, 0% 70%, 10% 50%);}
        .turbine-blade.b1 { transform: rotate(0deg) translateX(0px) translateY(-3px);}
        .turbine-blade.b2 { transform: rotate(120deg) translateX(0px) translateY(-3px);}
        .turbine-blade.b3 { transform: rotate(240deg) translateX(0px) translateY(-3px);}
        .turbine-spinner-center { position: absolute; width: 16px; height: 16px; left: 50%; top: 50%; transform: translate(-50%,-50%); background: #014282; border-radius: 50%; border: 2px solid #fff;}
        @keyframes spinner-rotate { 100% { transform: rotate(360deg);} }
        .hotspot-label { position: absolute; background: #014282; color: #fff; padding: 2px 8px; border-radius: 0 !important; font-size: 0.95rem; pointer-events: none; white-space: nowrap; z-index: 20;}
        .hotspot-popup { position: absolute; background: #fff; color: #222; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); padding: 1.5rem 1.5rem 1rem 1.5rem; min-width: 260px; z-index: 25; left: 50%; top: 20%; transform: translateX(-50%); display: none;}
        .hotspot-popup h3 { margin-top: 0; }
        .hotspot-popup .close-btn { position: absolute; top: 8px; right: 12px; background: none; border: none; font-size: 1.2rem; cursor: pointer;}
        .back-btn { display:none; position:fixed; top:32px; left:32px; width:48px; height:48px; padding:0; background:none; border:none; z-index:9; cursor:pointer;}
        .back-btn svg { display:block; width:100%; height:100%;}
    </style>
</head>
<body>
    <div id="fade-overlay" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:#fff;opacity:0;pointer-events:none;z-index:9999;transition:opacity 0.5s;"></div>
    <div id="loading-overlay">
        <div class="turbine-spinner" id="turbineSpinner">
            <div class="turbine-blade b1"></div>
            <div class="turbine-blade b2"></div>
            <div class="turbine-blade b3"></div>
            <div class="turbine-spinner-center"></div>
        </div>
        <p class="welcome-text">Welcome to Turbine Tour</p>
    </div>
    <div id="webgl-output"></div>
    <div id="hotspot-popup" class="hotspot-popup">
        <button class="close-btn" onclick="document.getElementById('hotspot-popup').style.display='none'">&times;</button>
        <h3 id="popup-title"></h3>
        <p id="popup-desc"></p>
        <button id="explore-btn" class="bg-blue-600 text-white px-3 py-1 rounded mt-2">Explore</button>
    </div>
    <button id="back-btn" class="back-btn" title="Back to main">
        <svg viewBox="0 0 48 48">
            <rect x="0" y="0" width="48" height="48" fill="#014282"/>
            <polyline points="30,16 20,24 30,32" fill="none" stroke="#fff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
    // ====== MATERIAL STATE ======
    // Store material references and originals for toggling opacity (for nacelle, spoiler, transparent_flip)
    let nacelleSpoilerTransparentMats = [];
    let nacelleSpoilerOriginals = [];
    // Store Tower mesh/material for double-sided adjustment
    let towerMaterialRef = null;

    // ========== CAMERA, CONTROLS, SCENE, RENDERER ==============
    let scene, camera, renderer;
    let controls = {};
    let activeView = "main";
    let allHotspotMeshes = [];
    let allHotspotLabels = [];
    let bladesModel = null, bladesPivot = null;
    let towerPointLight = null; // For the light near the tower hotspot

    const loadingOverlay = document.getElementById('loading-overlay');
    const container = document.getElementById('webgl-output');
    const fadeOverlay = document.getElementById('fade-overlay');

    // ---- Sensor size (filmGauge) setting (Default: 35mm) ----
    // You can change this value as needed; it applies to all cameras.
    const DEFAULT_SENSOR_SIZE = 35; // mm

    // ========== HOTSPOT DATA ==========
    // Hotspot positions are used for camera targets and to place the tower light
    const hotspotData = {
        main: [
            { name: "Turbine", position: {x: 0, y: 187, z: -10}, title: "Turbine", desc: "Go in-depth inside the Turbine.", view: "turbain" },
            { name: "Tower", position: {x: 0, y: 10, z: 0}, title: "Tower", desc: "Go in-depth inside the Tower.", view: "tower" },
            { name: "Car", position: {x: 25, y: 3, z: 1}, title: "Car", desc: "Go to Service Van.", view: "car" }
        ],
        turbain: [
            { name: "Hub", position: {x: 1, y: 188, z: 5}, title: "Hub", desc: "Drivetrain details" },
            { name: "Yaw", position: {x: 2, y: 183, z: -8}, title: "Yaw", desc: "Yaw system details" },
            { name: "Hydraulics", position: {x: -3, y: 189, z: -12}, title: "Hydraulics", desc: "Hydraulics details" },
            { name: "Power Generator", position: {x: 0, y: 193, z: -14}, title: "Power Generator", desc: "Power Generator details" },
            { name: "Controls & Safety", position: {x: -7, y: 188, z: -18}, title: "Controls & Safety", desc: "Controls & Safety details" },
            { name: "Turbine System", position: {x: -4, y: 185, z: -12}, title: "Turbine System", desc: "Turbine System details" },
            { name: "Power Supply", position: {x: 1, y: 185, z: -18}, title: "Power Supply", desc: "Power Supply details" }
        ],
        tower: [
            { name: "Safety", position: {x: -18, y: 15, z: -25}, title: "Safety", desc: "Safety details" },
            { name: "Turbine Operation", position: {x: +6, y: 8, z: -4}, title: "Turbine Operation", desc: "Turbine Operation details" }
        ],
        car: [
            { name: "Scheduled Service", position: {x: 22, y: 1, z: 3}, title: "Scheduled Service", desc: "Scheduled Service info" },
            { name: "Documentation", position: {x: 20, y: 3, z: 1}, title: "Documentation", desc: "Documentation info" },
            { name: "Trouble Shooting Tools", position: {x: 30, y: 0, z: 3}, title: "Trouble Shooting Tools", desc: "Trouble Shooting Tools info" }
        ]
    };
    function getHotspotVector(hotspot) { return new THREE.Vector3(hotspot.position.x, hotspot.position.y, hotspot.position.z); }

    // ========== CAMERA SETUP ==========
    // All cameras (main, turbain, tower, car) are set up with their own controls and positions.
    // SENSOR SIZE (filmGauge) is set for all cameras and can be adjusted easily.
    const cameras = {};
    // Main camera: Orbits around the whole turbine. Only allows positive Y (above ground) movement.
    cameras.main = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    cameras.main.position.set(300, 90, 240);
    cameras.main.filmGauge = DEFAULT_SENSOR_SIZE;

    // Turbine (nacelle) camera: Focuses on nacelle area.
    cameras.turbain = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 0.1, 2000);
    cameras.turbain.position.set(0, 300, 0);
    cameras.turbain.filmGauge = DEFAULT_SENSOR_SIZE;

    // Tower camera: Pointer-lock camera for FPS-style navigation inside the tower.
    cameras.tower = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    cameras.tower.position.set(0, 8, -5);
    cameras.tower.filmGauge = DEFAULT_SENSOR_SIZE;

    // Car/van camera: Orbits around the car, at a 45-degree angle, allows only 180Â° orbit and no negative Y.
    cameras.car = new THREE.PerspectiveCamera(10, window.innerWidth / window.innerHeight, 0.1, 2000);
    cameras.car.position.set(
        // Orbit at a 45-degree angle and closer to the van.
        hotspotData.car[0].position.x + 50, 
        hotspotData.car[0].position.y + 0, 
        hotspotData.car[0].position.z + 15
    );
    cameras.car.filmGauge = DEFAULT_SENSOR_SIZE;

    // ---- Controls ----
    // Main camera controls: Only allow orbit above ground (no negative Y)
    controls.main = new THREE.OrbitControls(cameras.main, container);
    controls.main.target.copy(getHotspotVector(hotspotData.main[0]));
    controls.main.enableDamping = true;
    controls.main.dampingFactor = 0.05;
    controls.main.enablePan = false;
    controls.main.enableZoom = false;
    controls.main.minPolarAngle = 0;                // Do not allow camera under the ground
    controls.main.maxPolarAngle = Math.PI / 2;      // Only above ground

    // Turbine controls: Standard orbit controls
    controls.turbain = new THREE.OrbitControls(cameras.turbain, container);
    controls.turbain.target.copy(getHotspotVector(hotspotData.turbain[0]));
    controls.turbain.enableDamping = true;
    controls.turbain.dampingFactor = 0.05;
    controls.turbain.enablePan = false;
    controls.turbain.enableZoom = false;

    // Tower controls: FPS-style inside the tower.
    controls.tower = new THREE.PointerLockControls(cameras.tower, container);

    // Car camera controls: Only 180Â° around van, no negative Y, start at 45Â° angle.
    controls.car = new THREE.OrbitControls(cameras.car, container);
    controls.car.target.copy(getHotspotVector(hotspotData.car[0]));
    controls.car.enableDamping = true;
    controls.car.dampingFactor = 0.05;
    controls.car.enablePan = false;
    controls.car.enableZoom = false;
    controls.car.minAzimuthAngle = Math.PI / 4;     // Start at 45Â°
    controls.car.maxAzimuthAngle = (5 * Math.PI) / 4; // 180Â° arc from 45Â° to 225Â°
    controls.car.minPolarAngle = 0;                 // Only above ground
    controls.car.maxPolarAngle = Math.PI / 2;

    // ========== MATERIAL TWEAKS ==========
    // Set nacelle/spoiler/transparent_flip opacity (hide/show them)
    function setNacelleSpoilerMaterialsOpacity(alpha) {
        nacelleSpoilerTransparentMats.forEach(mat => {
            mat.transparent = true;
            mat.opacity = alpha;
            mat.needsUpdate = true;
        });
    }
    function restoreNacelleSpoilerMaterials() {
        nacelleSpoilerOriginals.forEach(orig => {
            orig.mat.opacity = orig.opacity;
            orig.mat.transparent = orig.transparent;
            orig.mat.needsUpdate = true;
        });
    }
    // Set Tower material to double-sided so it's visible from inside and outside
    function makeTowerMaterialDoubleSided() {
        if (towerMaterialRef) {
            towerMaterialRef.side = THREE.DoubleSide; // Ensures rendering both faces
            towerMaterialRef.needsUpdate = true;
            // If you still see through the tower from inside, your mesh normals may be flipped inward.
            // To fix, you can flip the normals in your 3D software, or do it in code:
            // child.geometry.computeVertexNormals();
            // or
            // child.geometry.scale(-1, 1, 1); // This inverts X normals (use with caution)
        }
    }

    // ========== INIT ==========
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a202c);
        camera = cameras.main;
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Ambient and directional lighting for general scene
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- LOAD MODELS HERE ---
        const loader = new THREE.GLTFLoader();
        loader.load('windmillenv.glb', function (gltf) {
            const model = gltf.scene;
            model.scale.set(2, 2, 2);
            scene.add(model);

            // 1. Find nacelle, spoiler, transparent_flip materials
            nacelleSpoilerTransparentMats = [];
            nacelleSpoilerOriginals = [];
            const matNames = ["Nacelle_outershell", "spoiler_outer", "Transparent_flip"];
            model.traverse(function(child) {
                if (child.isMesh) {
                    // 2. Find Tower mesh/material and make it double-sided
                    if (child.name && child.name.toLowerCase().includes("tower")) {
                        let towerMats = Array.isArray(child.material) ? child.material : [child.material];
                        towerMats.forEach(mat => {
                            if (mat && !towerMaterialRef) {
                                towerMaterialRef = mat;
                                makeTowerMaterialDoubleSided();
                            }
                        });
                    }
                    // 3. Store refs for nacelle/spoiler/transparent_flip
                    let materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        if (mat && matNames.includes(mat.name)) {
                            nacelleSpoilerTransparentMats.push(mat);
                            nacelleSpoilerOriginals.push({
                                mat: mat,
                                opacity: mat.opacity,
                                transparent: mat.transparent
                            });
                        }
                    });
                }
            });

            // 4. Add a point light near the Tower hotspot
            const towerHotspot = hotspotData.tower[0];
            if (towerHotspot && !towerPointLight) {
                towerPointLight = new THREE.PointLight(0xffee88, 1, 10);
                towerPointLight.position.set(towerHotspot.position.x+10, towerHotspot.position.y -5, towerHotspot.position.z + 0);
                scene.add(towerPointLight);
            }

            loadingOverlay.style.display = 'none';
        });

        // Add windmill blades (spinning)
        bladesPivot = new THREE.Object3D();
        bladesPivot.position.set(0, 187, 0);
        scene.add(bladesPivot);
        loader.load('Blades.glb', function (gltf) {
            bladesModel = gltf.scene;
            bladesModel.scale.set(2, 2, 2);
            bladesPivot.add(bladesModel);
        });

        showHotspots("main");
        window.addEventListener('resize', onWindowResize, false);
        container.addEventListener('click', function() {
            if (activeView === "tower" && !controls.tower.isLocked) controls.tower.lock();
        });
    }
    function onWindowResize() {
        for (let k in cameras) {
            cameras[k].aspect = window.innerWidth / window.innerHeight;
            cameras[k].updateProjectionMatrix();
        }
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function createHotspotMesh(hotspot, idx) {
        const map = new THREE.TextureLoader().load(
            `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='28' fill='${encodeURIComponent("#014282")}' fill-opacity='0.8'/></svg>`
        );
        const mat = new THREE.SpriteMaterial({ map: map, transparent: true, opacity: 0.5, depthTest: false });
        const sprite = new THREE.Sprite(mat);
        sprite.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
        let size = getHotspotSize(activeView);
        sprite.scale.set(size, size, 1);
        sprite.renderOrder = 999;
        sprite.userData.hotspotIndex = idx;
        sprite.userData.hotspot = hotspot;
        return sprite;
    }
    const HOTSPOT_BASE_SIZE = 3;
    function getHotspotSize(view) { return view === "main" ? HOTSPOT_BASE_SIZE * 3 : HOTSPOT_BASE_SIZE; }
    function showHotspots(view) {
        allHotspotMeshes.forEach(mesh => scene.remove(mesh));
        allHotspotLabels.forEach(label => { if (label && label.remove) label.remove(); });
        allHotspotMeshes = [];
        allHotspotLabels = [];
        hotspotData[view].forEach((hotspot, idx) => {
            const mesh = createHotspotMesh(hotspot, idx);
            scene.add(mesh);
            allHotspotMeshes.push(mesh);
            const label = document.createElement('div');
            label.className = 'hotspot-label';
            label.innerText = hotspot.name;
            document.body.appendChild(label);
            allHotspotLabels.push(label);
        });
    }

    // ========== CAMERA SWITCH LOGIC ==========
    function switchView(view) {
        fadeTransition(() => {
            activeView = view;
            camera = cameras[view];
            Object.entries(controls).forEach(([k, ctrl]) => ctrl.enabled = (k === view));
            if (view === "tower") {
                if (!controls.tower.isLocked) controls.tower.lock();
            }
            if(view==="main") controls.main.target.copy(getHotspotVector(hotspotData.main[0]));
            if(view==="turbain") controls.turbain.target.copy(getHotspotVector(hotspotData.turbain[0]));
            if(view==="car") controls.car.target.copy(getHotspotVector(hotspotData.car[0]));
            showHotspots(view);
            document.getElementById("back-btn").style.display = (view === "main") ? "none" : "block";

            // When entering "turbain" view, hide nacelle/spoiler/transparent_flip
            if (view === "turbain") {
                setNacelleSpoilerMaterialsOpacity(0.0);
            }
            // When returning to main, restore their visibility
            else if (view === "main") {
                restoreNacelleSpoilerMaterials();
            }
        });
    }

    // ==== Helper for fade transitions ====
    function fadeTransition(cb) {
        fadeOverlay.style.pointerEvents = 'auto';
        fadeOverlay.style.opacity = 1;
        setTimeout(() => {
            cb();
            setTimeout(() => {
                fadeOverlay.style.opacity = 0;
                setTimeout(() => { fadeOverlay.style.pointerEvents = 'none'; }, 500);
            }, 100);
        }, 500);
    }

    // --- Hotspot Interactivity ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let INTERSECTED = null;
    const popup = document.getElementById('hotspot-popup');
    const popupTitle = document.getElementById('popup-title');
    const popupDesc = document.getElementById('popup-desc');
    const exploreBtn = document.getElementById('explore-btn');
    function setupHotspotEvents() {
        renderer.domElement.addEventListener('mousemove', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allHotspotMeshes);
            allHotspotLabels.forEach(label => label.style.display = 'none');
            INTERSECTED = null;
            if (intersects.length > 0) {
                const idx = intersects[0].object.userData.hotspotIndex;
                INTERSECTED = idx;
                allHotspotLabels[idx].style.display = 'block';
                const vector = allHotspotMeshes[idx].position.clone().project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                allHotspotLabels[idx].style.left = `${x}px`;
                allHotspotLabels[idx].style.top = `${y - 30}px`;
            }
        });
        renderer.domElement.addEventListener('mouseleave', () => {
            allHotspotLabels.forEach(label => label.style.display = 'none');
            INTERSECTED = null;
        });
        renderer.domElement.addEventListener('click', (event) => {
            if (INTERSECTED !== null) {
                const hotspot = hotspotData[activeView][INTERSECTED];
                if (activeView === "main" && hotspot.view) {
                    switchView(hotspot.view);
                } else {
                    popupTitle.innerText = hotspot.title;
                    popupDesc.innerText = hotspot.desc;
                    popup.style.display = 'block';
                    exploreBtn.onclick = () => window.open('#', '_blank');
                }
            }
        });
    }
    document.querySelector('.close-btn').onclick = () => { popup.style.display = 'none'; };
    document.getElementById('back-btn').onclick = () => { switchView("main"); };
    function updateHotspotLabels() {
        allHotspotMeshes.forEach((mesh, idx) => {
            if (allHotspotLabels[idx].style.display === 'block') {
                const vector = mesh.position.clone().project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                allHotspotLabels[idx].style.left = `${x}px`;
                allHotspotLabels[idx].style.top = `${y - 30}px`;
            }
        });
    }
    function animateFn() {
        requestAnimationFrame(animateFn);
        if (controls[activeView] && controls[activeView].update) controls[activeView].update();
        if (bladesPivot) bladesPivot.rotation.z += 0.02;
        renderer.render(scene, camera);
        allHotspotMeshes.forEach((sprite, idx) => {
            let size = getHotspotSize(activeView);
            sprite.scale.set(size, size, 1);
        });
        updateHotspotLabels();
    }
    window.onload = function () {
        init();
        setupHotspotEvents();
        animateFn();
    };
    </script>
</body>
</html>
